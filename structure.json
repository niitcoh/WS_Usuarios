{
  "src": {
    "config": {
      "auth.js": "const jwt = require('jsonwebtoken');\r\nrequire('dotenv').config();\r\n\r\nmodule.exports = {\r\n  generateToken: (userId, email, rol) => {\r\n    return jwt.sign(\r\n      { id: userId, email, rol },\r\n      process.env.JWT_SECRET,\r\n      { expiresIn: process.env.JWT_EXPIRES_IN }\r\n    );\r\n  },\r\n  \r\n  verifyToken: (token) => {\r\n    try {\r\n      return jwt.verify(token, process.env.JWT_SECRET);\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n};\r\n",
      "database.js": "\r\nconst mysql = require('mysql2/promise');\r\nrequire('dotenv').config();\r\n\r\nconst pool = mysql.createPool({\r\n  host: process.env.DB_HOST,\r\n  user: process.env.DB_USER,\r\n  password: process.env.DB_PASSWORD,\r\n  database: process.env.DB_NAME,\r\n  waitForConnections: true,\r\n  connectionLimit: 10,\r\n  queueLimit: 0\r\n});\r\n\r\nmodule.exports = pool;"
    },
    "controllers": {
      "auth.controller.js": "const Usuario = require('../models/usuario.model');\r\nconst Token = require('../models/token.model');\r\nconst authConfig = require('../config/auth');\r\nconst nodemailer = require('nodemailer');\r\nrequire('dotenv').config();\r\n\r\n// Configurar nodemailer\r\nconst transporter = nodemailer.createTransport({\r\n  service: 'gmail',\r\n  auth: {\r\n    user: process.env.EMAIL_USER,\r\n    pass: process.env.EMAIL_PASS\r\n  }\r\n});\r\n\r\nexports.login = async (req, res) => {\r\n  try {\r\n    const { email, password } = req.body;\r\n    \r\n    // Validar que se proporcionen email y password\r\n    if (!email || !password) {\r\n      return res.status(400).json({ message: 'Email y contraseña son requeridos' });\r\n    }\r\n    \r\n    // Buscar usuario por email\r\n    const usuario = await Usuario.getByEmail(email);\r\n    \r\n    // Verificar si existe el usuario\r\n    if (!usuario) {\r\n      return res.status(401).json({ message: 'Credenciales inválidas' });\r\n    }\r\n    \r\n    // Verificar si el usuario está activo\r\n    if (!usuario.activo) {\r\n      return res.status(401).json({ message: 'Usuario inactivo' });\r\n    }\r\n    \r\n    // Verificar contraseña\r\n    const passwordValida = await Usuario.validatePassword(password, usuario.password);\r\n    \r\n    if (!passwordValida) {\r\n      return res.status(401).json({ message: 'Credenciales inválidas' });\r\n    }\r\n    \r\n    // Generar token JWT\r\n    const token = authConfig.generateToken(usuario.id, usuario.email, usuario.rol);\r\n    \r\n    // Actualizar último acceso\r\n    await Usuario.updateLastAccess(usuario.id);\r\n    \r\n    // Datos a devolver (sin password)\r\n    delete usuario.password;\r\n    \r\n    // Obtener direcciones\r\n    const direcciones = await Usuario.getDireccionesByUsuarioId(usuario.id);\r\n    \r\n    res.status(200).json({\r\n      message: 'Login exitoso',\r\n      token,\r\n      usuario: {\r\n        ...usuario,\r\n        direcciones\r\n      }\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error en el servidor' });\r\n  }\r\n};\r\n\r\nexports.register = async (req, res) => {\r\n  try {\r\n    const { \r\n      rut, \r\n      nombre, \r\n      apellido, \r\n      email, \r\n      password, \r\n      telefono, \r\n      direccion,\r\n      comuna,\r\n      ciudad,\r\n      region\r\n    } = req.body;\r\n    \r\n    // Validaciones básicas\r\n    if (!nombre || !email || !password) {\r\n      return res.status(400).json({ \r\n        message: 'Nombre, email y contraseña son requeridos' \r\n      });\r\n    }\r\n    \r\n    // Verificar si ya existe un usuario con ese email\r\n    const usuarioExistente = await Usuario.getByEmail(email);\r\n    \r\n    if (usuarioExistente) {\r\n      return res.status(400).json({ message: 'El email ya está registrado' });\r\n    }\r\n    \r\n    // Verificar si ya existe un usuario con ese RUT (si se proporciona)\r\n    if (rut) {\r\n      const rutExistente = await Usuario.getByRut(rut);\r\n      \r\n      if (rutExistente) {\r\n        return res.status(400).json({ message: 'El RUT ya está registrado' });\r\n      }\r\n    }\r\n    \r\n    // Crear el usuario (por defecto con rol 'cliente')\r\n    const usuarioId = await Usuario.create({\r\n      rut: rut || `${Math.floor(Math.random() * 20000000) + 5000000}-${Math.floor(Math.random() * 10)}`,\r\n      nombre,\r\n      apellido: apellido || 'No especificado',\r\n      email,\r\n      password,\r\n      telefono,\r\n      rol: 'cliente',\r\n      // Datos de dirección si se proporcionan\r\n      direccion,\r\n      comuna,\r\n      ciudad,\r\n      region\r\n    });\r\n    \r\n    // Obtener el usuario creado\r\n    const nuevoUsuario = await Usuario.getById(usuarioId);\r\n    \r\n    // Generar token JWT\r\n    const token = authConfig.generateToken(nuevoUsuario.id, nuevoUsuario.email, nuevoUsuario.rol);\r\n    \r\n    res.status(201).json({\r\n      message: 'Usuario registrado exitosamente',\r\n      token,\r\n      usuario: nuevoUsuario\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error en el servidor' });\r\n  }\r\n};\r\n\r\nexports.forgotPassword = async (req, res) => {\r\n  try {\r\n    const { email } = req.body;\r\n    \r\n    if (!email) {\r\n      return res.status(400).json({ message: 'Email es requerido' });\r\n    }\r\n    \r\n    // Verificar si existe el usuario\r\n    const usuario = await Usuario.getByEmail(email);\r\n    \r\n    if (!usuario) {\r\n      // Por seguridad, no revelar si el email existe o no\r\n      return res.status(200).json({ message: 'Si el email existe, recibirás instrucciones para recuperar tu contraseña' });\r\n    }\r\n    \r\n    // Generar token de recuperación\r\n    const { token } = await Token.createRecoveryToken(usuario.id);\r\n    \r\n    if (!token) {\r\n      return res.status(500).json({ message: 'Error al generar token de recuperación' });\r\n    }\r\n    \r\n    // Enviar email con link de recuperación\r\n    const resetUrl = `http://localhost:5500/reset-password.html?token=${token}`;\r\n    \r\n    const mailOptions = {\r\n      from: process.env.EMAIL_USER,\r\n      to: email,\r\n      subject: 'Recuperación de contraseña - Ferremas',\r\n      html: `\r\n        <h2>Recuperación de contraseña</h2>\r\n        <p>Has solicitado restablecer tu contraseña.</p>\r\n        <p>Haz clic en el siguiente enlace para crear una nueva contraseña:</p>\r\n        <a href=\"${resetUrl}\" style=\"display:inline-block;background:#1a4d7c;color:white;padding:10px 20px;text-decoration:none;border-radius:5px;\">Restablecer contraseña</a>\r\n        <p>Este enlace expirará en 1 hora.</p>\r\n        <p>Si no solicitaste este cambio, ignora este correo.</p>\r\n      `\r\n    };\r\n    \r\n    await transporter.sendMail(mailOptions);\r\n    \r\n    res.status(200).json({ message: 'Si el email existe, recibirás instrucciones para recuperar tu contraseña' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error en el servidor' });\r\n  }\r\n};\r\n\r\nexports.resetPassword = async (req, res) => {\r\n  try {\r\n    const { token, newPassword } = req.body;\r\n    \r\n    if (!token || !newPassword) {\r\n      return res.status(400).json({ message: 'Token y nueva contraseña son requeridos' });\r\n    }\r\n    \r\n    // Validar token\r\n    const tokenInfo = await Token.validateToken(token, 'reset_password');\r\n    \r\n    if (!tokenInfo) {\r\n      return res.status(400).json({ message: 'Token inválido o expirado' });\r\n    }\r\n    \r\n    // Cambiar contraseña\r\n    await Usuario.changePassword(tokenInfo.usuario_id, newPassword);\r\n    \r\n    // Marcar token como usado\r\n    await Token.markAsUsed(tokenInfo.id);\r\n    \r\n    res.status(200).json({ message: 'Contraseña actualizada exitosamente' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error en el servidor' });\r\n  }\r\n};\r\n\r\nexports.validateToken = (req, res) => {\r\n  // El middleware auth.middleware.js ya validó el token\r\n  // Solo retornamos los datos del usuario obtenidos de req.user\r\n  res.status(200).json({\r\n    message: 'Token válido',\r\n    usuario: req.user\r\n  });\r\n};\r\n",
      "direcciones.controller.js": "const Direccion = require('../models/direccion.model');\r\nconst Usuario = require('../models/usuario.model');\r\n\r\nexports.getDireccionesByUsuario = async (req, res) => {\r\n  try {\r\n    const usuarioId = req.params.usuarioId;\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === parseInt(usuarioId);\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para ver estas direcciones' });\r\n    }\r\n    \r\n    const direcciones = await Direccion.getByUsuarioId(usuarioId);\r\n    \r\n    res.status(200).json(direcciones);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al obtener direcciones' });\r\n  }\r\n};\r\n\r\nexports.getDireccionById = async (req, res) => {\r\n  try {\r\n    const direccion = await Direccion.getById(req.params.id);\r\n    \r\n    if (!direccion) {\r\n      return res.status(404).json({ message: 'Dirección no encontrada' });\r\n    }\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === direccion.usuario_id;\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para ver esta dirección' });\r\n    }\r\n    \r\n    res.status(200).json(direccion);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al obtener la dirección' });\r\n  }\r\n};\r\n\r\nexports.createDireccion = async (req, res) => {\r\n  try {\r\n    const { \r\n      usuario_id, \r\n      direccion, \r\n      comuna, \r\n      ciudad, \r\n      region, \r\n      codigo_postal, \r\n      telefono, \r\n      instrucciones, \r\n      predeterminada \r\n    } = req.body;\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === parseInt(usuario_id);\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para crear direcciones para este usuario' });\r\n    }\r\n    \r\n    // Validaciones básicas\r\n    if (!direccion || !comuna || !ciudad || !region) {\r\n      return res.status(400).json({ message: 'Dirección, comuna, ciudad y región son campos requeridos' });\r\n    }\r\n    \r\n    // Verificar que el usuario existe\r\n    const usuario = await Usuario.getById(usuario_id);\r\n    \r\n    if (!usuario) {\r\n      return res.status(404).json({ message: 'Usuario no encontrado' });\r\n    }\r\n    \r\n    const direccionId = await Direccion.create({\r\n      usuario_id,\r\n      direccion,\r\n      comuna,\r\n      ciudad,\r\n      region,\r\n      codigo_postal,\r\n      telefono,\r\n      instrucciones,\r\n      predeterminada: predeterminada || false\r\n    });\r\n    \r\n    const nuevaDireccion = await Direccion.getById(direccionId);\r\n    \r\n    res.status(201).json({\r\n      message: 'Dirección creada exitosamente',\r\n      direccion: nuevaDireccion\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al crear la dirección' });\r\n  }\r\n};\r\n\r\nexports.updateDireccion = async (req, res) => {\r\n  try {\r\n    const direccionId = req.params.id;\r\n    const direccionExistente = await Direccion.getById(direccionId);\r\n    \r\n    if (!direccionExistente) {\r\n      return res.status(404).json({ message: 'Dirección no encontrada' });\r\n    }\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === direccionExistente.usuario_id;\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para actualizar esta dirección' });\r\n    }\r\n    \r\n    const resultado = await Direccion.update(direccionId, req.body);\r\n    \r\n    if (!resultado) {\r\n      return res.status(400).json({ message: 'No se proporcionaron datos para actualizar' });\r\n    }\r\n    \r\n    const direccionActualizada = await Direccion.getById(direccionId);\r\n    \r\n    res.status(200).json({\r\n      message: 'Dirección actualizada exitosamente',\r\n      direccion: direccionActualizada\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al actualizar la dirección' });\r\n  }\r\n};\r\n\r\nexports.deleteDireccion = async (req, res) => {\r\n  try {\r\n    const direccionId = req.params.id;\r\n    const direccionExistente = await Direccion.getById(direccionId);\r\n    \r\n    if (!direccionExistente) {\r\n      return res.status(404).json({ message: 'Dirección no encontrada' });\r\n    }\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === direccionExistente.usuario_id;\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para eliminar esta dirección' });\r\n    }\r\n    \r\n    await Direccion.delete(direccionId);\r\n    \r\n    res.status(200).json({ message: 'Dirección eliminada exitosamente' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al eliminar la dirección' });\r\n  }\r\n};\r\n\r\nexports.setDireccionPredeterminada = async (req, res) => {\r\n  try {\r\n    const direccionId = req.params.id;\r\n    const direccionExistente = await Direccion.getById(direccionId);\r\n    \r\n    if (!direccionExistente) {\r\n      return res.status(404).json({ message: 'Dirección no encontrada' });\r\n    }\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === direccionExistente.usuario_id;\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para actualizar esta dirección' });\r\n    }\r\n    \r\n    // Establecer como predeterminada\r\n    await Direccion.update(direccionId, { predeterminada: true });\r\n    \r\n    res.status(200).json({ message: 'Dirección establecida como predeterminada' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al establecer dirección predeterminada' });\r\n  }\r\n};",
      "roles.controller.js": "const pool = require('../config/database');\r\n\r\nexports.getAllRoles = async (req, res) => {\r\n  try {\r\n    const [roles] = await pool.query('SELECT * FROM roles ORDER BY id');\r\n    res.status(200).json(roles);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al obtener roles' });\r\n  }\r\n};\r\n\r\nexports.getRolById = async (req, res) => {\r\n  try {\r\n    const [rows] = await pool.query(\r\n      'SELECT * FROM roles WHERE id = ?',\r\n      [req.params.id]\r\n    );\r\n    \r\n    if (rows.length === 0) {\r\n      return res.status(404).json({ message: 'Rol no encontrado' });\r\n    }\r\n    \r\n    res.status(200).json(rows[0]);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al obtener el rol' });\r\n  }\r\n};\r\n\r\nexports.createRol = async (req, res) => {\r\n  try {\r\n    const { nombre, descripcion } = req.body;\r\n    \r\n    if (!nombre) {\r\n      return res.status(400).json({ message: 'El nombre es requerido' });\r\n    }\r\n    \r\n    // Verificar si ya existe un rol con ese nombre\r\n    const [existente] = await pool.query('SELECT id FROM roles WHERE nombre = ?', [nombre]);\r\n    \r\n    if (existente.length > 0) {\r\n      return res.status(400).json({ message: 'Ya existe un rol con ese nombre' });\r\n    }\r\n    \r\n    const [result] = await pool.query(\r\n      'INSERT INTO roles (nombre, descripcion) VALUES (?, ?)',\r\n      [nombre, descripcion || null]\r\n    );\r\n    \r\n    res.status(201).json({\r\n      id: result.insertId,\r\n      nombre,\r\n      descripcion\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al crear el rol' });\r\n  }\r\n};\r\n\r\nexports.updateRol = async (req, res) => {\r\n  try {\r\n    const { nombre, descripcion } = req.body;\r\n    \r\n    if (!nombre) {\r\n      return res.status(400).json({ message: 'El nombre es requerido' });\r\n    }\r\n    \r\n    // Verificar si ya existe un rol con ese nombre (que no sea el mismo rol)\r\n    const [existente] = await pool.query(\r\n      'SELECT id FROM roles WHERE nombre = ? AND id != ?',\r\n      [nombre, req.params.id]\r\n    );\r\n    \r\n    if (existente.length > 0) {\r\n      return res.status(400).json({ message: 'Ya existe un rol con ese nombre' });\r\n    }\r\n    \r\n    const [result] = await pool.query(\r\n      'UPDATE roles SET nombre = ?, descripcion = ? WHERE id = ?',\r\n      [nombre, descripcion || null, req.params.id]\r\n    );\r\n    \r\n    if (result.affectedRows === 0) {\r\n      return res.status(404).json({ message: 'Rol no encontrado' });\r\n    }\r\n    \r\n    res.status(200).json({\r\n      id: parseInt(req.params.id),\r\n      nombre,\r\n      descripcion\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al actualizar el rol' });\r\n  }\r\n};\r\n\r\nexports.deleteRol = async (req, res) => {\r\n  try {\r\n    // Verificar si hay usuarios con este rol\r\n    const [usuarios] = await pool.query(\r\n      'SELECT COUNT(*) as count FROM usuarios WHERE rol_id = ?',\r\n      [req.params.id]\r\n    );\r\n    \r\n    if (usuarios[0].count > 0) {\r\n      return res.status(400).json({ \r\n        message: 'No se puede eliminar el rol porque está asignado a uno o más usuarios'\r\n      });\r\n    }\r\n    \r\n    const [result] = await pool.query(\r\n      'DELETE FROM roles WHERE id = ?',\r\n      [req.params.id]\r\n    );\r\n    \r\n    if (result.affectedRows === 0) {\r\n      return res.status(404).json({ message: 'Rol no encontrado' });\r\n    }\r\n    \r\n    res.status(200).json({ message: 'Rol eliminado exitosamente' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al eliminar el rol' });\r\n  }\r\n};\r\n",
      "usuarios.controller.js": "const Usuario = require('../models/usuario.model');\r\nconst Direccion = require('../models/direccion.model');\r\nconst pool = require('../config/database');\r\n\r\nexports.getAllUsuarios = async (req, res) => {\r\n  try {\r\n    const usuarios = await Usuario.getAll();\r\n    res.status(200).json(usuarios);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al obtener usuarios' });\r\n  }\r\n};\r\n\r\nexports.getUsuarioById = async (req, res) => {\r\n  try {\r\n    const usuario = await Usuario.getById(req.params.id);\r\n    \r\n    if (!usuario) {\r\n      return res.status(404).json({ message: 'Usuario no encontrado' });\r\n    }\r\n    \r\n    res.status(200).json(usuario);\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al obtener el usuario' });\r\n  }\r\n};\r\n\r\nexports.updateUsuario = async (req, res) => {\r\n  try {\r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === parseInt(req.params.id);\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para actualizar este usuario' });\r\n    }\r\n    \r\n    // Si es admin, puede actualizar cualquier campo\r\n    // Si es el propio usuario, solo puede actualizar ciertos campos\r\n    const datosActualizacion = esAdmin ? req.body : {\r\n      nombre: req.body.nombre,\r\n      apellido: req.body.apellido,\r\n      telefono: req.body.telefono\r\n    };\r\n    \r\n    const resultado = await Usuario.update(req.params.id, datosActualizacion);\r\n    \r\n    if (!resultado) {\r\n      return res.status(404).json({ message: 'Usuario no encontrado o no se proporcionaron datos para actualizar' });\r\n    }\r\n    \r\n    const usuarioActualizado = await Usuario.getById(req.params.id);\r\n    \r\n    res.status(200).json({\r\n      message: 'Usuario actualizado exitosamente',\r\n      usuario: usuarioActualizado\r\n    });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al actualizar el usuario' });\r\n  }\r\n};\r\n\r\nexports.changePassword = async (req, res) => {\r\n  try {\r\n    const { currentPassword, newPassword } = req.body;\r\n    const userId = req.params.id;\r\n    \r\n    // Verificar si es el propio usuario o un admin\r\n    const esPropio = req.user.id === parseInt(userId);\r\n    const esAdmin = req.user.rol === 'admin';\r\n    \r\n    if (!esPropio && !esAdmin) {\r\n      return res.status(403).json({ message: 'No tienes permiso para cambiar la contraseña de este usuario' });\r\n    }\r\n    \r\n    // Si es el propio usuario, verificar contraseña actual\r\n    if (esPropio && !esAdmin) {\r\n      // Obtener el usuario completo con password\r\n      const [usuario] = await pool.query('SELECT * FROM usuarios WHERE id = ?', [userId]);\r\n      \r\n      if (usuario.length === 0) {\r\n        return res.status(404).json({ message: 'Usuario no encontrado' });\r\n      }\r\n      \r\n      const passwordValida = await Usuario.validatePassword(currentPassword, usuario[0].password);\r\n      \r\n      if (!passwordValida) {\r\n        return res.status(400).json({ message: 'Contraseña actual incorrecta' });\r\n      }\r\n    }\r\n    \r\n    // Cambiar contraseña\r\n    await Usuario.changePassword(userId, newPassword);\r\n    \r\n    res.status(200).json({ message: 'Contraseña actualizada exitosamente' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al cambiar la contraseña' });\r\n  }\r\n};\r\n\r\nexports.deleteUsuario = async (req, res) => {\r\n  try {\r\n    // Solo admin puede eliminar usuarios\r\n    if (req.user.rol !== 'admin') {\r\n      return res.status(403).json({ message: 'No tienes permiso para eliminar usuarios' });\r\n    }\r\n    \r\n    const resultado = await Usuario.delete(req.params.id);\r\n    \r\n    if (!resultado) {\r\n      return res.status(404).json({ message: 'Usuario no encontrado' });\r\n    }\r\n    \r\n    res.status(200).json({ message: 'Usuario eliminado exitosamente' });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error al eliminar el usuario' });\r\n  }\r\n};\r\n"
    },
    "index.js": "const express = require('express');\r\nconst cors = require('cors');\r\nrequire('dotenv').config();\r\n\r\nconst app = express();\r\nconst port = process.env.PORT || 3003;\r\n\r\n// Middlewares\r\napp.use(cors({\r\n  origin: '*',\r\n  methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\r\n  credentials: true,\r\n  preflightContinue: false,\r\n  optionsSuccessStatus: 204\r\n}));\r\napp.use(express.json());\r\napp.use(express.urlencoded({ extended: true }));\r\n\r\n// Ruta básica\r\napp.get('/', (req, res) => {\r\n  res.json({ \r\n    message: 'API de Usuarios funcionando correctamente',\r\n    version: '1.1.0'\r\n  });\r\n});\r\n\r\n// Importar rutas\r\nconst authRoutes = require('./routes/auth.routes');\r\nconst usuariosRoutes = require('./routes/usuarios.routes');\r\nconst direccionesRoutes = require('./routes/direcciones.routes');\r\n\r\n// Usar rutas\r\napp.use('/api/auth', authRoutes);\r\napp.use('/api/usuarios', usuariosRoutes);\r\napp.use('/api/direcciones', direccionesRoutes);\r\n\r\n// Middleware para manejo de errores 404\r\napp.use((req, res) => {\r\n  res.status(404).json({ message: 'Ruta no encontrada' });\r\n});\r\n\r\n// Iniciar servidor\r\napp.listen(port, () => {\r\n  console.log(`Servidor de Usuarios corriendo en http://localhost:${port}`);\r\n});",
    "middleware": {
      "auth.middleware.js": "const authConfig = require('../config/auth');\r\nconst Usuario = require('../models/usuario.model');\r\n\r\nexports.verificarToken = async (req, res, next) => {\r\n  try {\r\n    // Obtener el token del header\r\n    const authHeader = req.headers.authorization;\r\n    \r\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n      return res.status(401).json({ message: 'Token no proporcionado' });\r\n    }\r\n    \r\n    const token = authHeader.split(' ')[1];\r\n    \r\n    // Verificar el token\r\n    const decoded = authConfig.verifyToken(token);\r\n    \r\n    if (!decoded) {\r\n      return res.status(401).json({ message: 'Token inválido o expirado' });\r\n    }\r\n    \r\n    // Verificar que el usuario existe y está activo\r\n    const usuario = await Usuario.getById(decoded.id);\r\n    \r\n    if (!usuario) {\r\n      return res.status(401).json({ message: 'Usuario no encontrado' });\r\n    }\r\n    \r\n    if (!usuario.activo) {\r\n      return res.status(401).json({ message: 'Usuario inactivo' });\r\n    }\r\n    \r\n    // Agregar información del usuario al request\r\n    req.user = usuario;\r\n    \r\n    next();\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Error en la autenticación' });\r\n  }\r\n};\r\n",
      "roles.middleware.js": "\r\n"
    },
    "models": {
      "direccion.model.js": "const pool = require('../config/database');\r\n\r\nclass Direccion {\r\n  static async getById(id) {\r\n    const [rows] = await pool.query(\r\n      'SELECT * FROM direcciones WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    return rows.length ? rows[0] : null;\r\n  }\r\n  \r\n  static async getByUsuarioId(usuarioId) {\r\n    const [rows] = await pool.query(\r\n      'SELECT * FROM direcciones WHERE usuario_id = ?',\r\n      [usuarioId]\r\n    );\r\n    \r\n    return rows;\r\n  }\r\n  \r\n  static async create(direccionData) {\r\n    // Si se marca como predeterminada, quitar predeterminada de otras direcciones\r\n    if (direccionData.predeterminada) {\r\n      await pool.query(\r\n        'UPDATE direcciones SET predeterminada = FALSE WHERE usuario_id = ?',\r\n        [direccionData.usuario_id]\r\n      );\r\n    }\r\n    \r\n    const [result] = await pool.query(\r\n      `INSERT INTO direcciones (\r\n        usuario_id, direccion, comuna, ciudad, region, \r\n        codigo_postal, telefono, instrucciones, predeterminada\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,\r\n      [\r\n        direccionData.usuario_id,\r\n        direccionData.direccion,\r\n        direccionData.comuna,\r\n        direccionData.ciudad,\r\n        direccionData.region,\r\n        direccionData.codigo_postal || null,\r\n        direccionData.telefono || null,\r\n        direccionData.instrucciones || null,\r\n        direccionData.predeterminada || false\r\n      ]\r\n    );\r\n    \r\n    return result.insertId;\r\n  }\r\n  \r\n  static async update(id, direccionData) {\r\n    // Si se marca como predeterminada, quitar predeterminada de otras direcciones\r\n    if (direccionData.predeterminada) {\r\n      const [direccion] = await pool.query('SELECT usuario_id FROM direcciones WHERE id = ?', [id]);\r\n      \r\n      if (direccion.length > 0) {\r\n        await pool.query(\r\n          'UPDATE direcciones SET predeterminada = FALSE WHERE usuario_id = ? AND id != ?',\r\n          [direccion[0].usuario_id, id]\r\n        );\r\n      }\r\n    }\r\n    \r\n    let updateQuery = 'UPDATE direcciones SET ';\r\n    const updateValues = [];\r\n    \r\n    // Construir la consulta dinámicamente con los campos proporcionados\r\n    for (const [key, value] of Object.entries(direccionData)) {\r\n      if (key !== 'id' && key !== 'usuario_id') {\r\n        updateQuery += `${key} = ?, `;\r\n        updateValues.push(value);\r\n      }\r\n    }\r\n    \r\n    // Si no hay campos para actualizar\r\n    if (updateValues.length === 0) {\r\n      return false;\r\n    }\r\n    \r\n    // Eliminar la última coma y espacio\r\n    updateQuery = updateQuery.slice(0, -2);\r\n    \r\n    // Agregar condición WHERE\r\n    updateQuery += ' WHERE id = ?';\r\n    updateValues.push(id);\r\n    \r\n    const [result] = await pool.query(updateQuery, updateValues);\r\n    return result.affectedRows > 0;\r\n  }\r\n  \r\n  static async delete(id) {\r\n    // Verificar si la dirección a eliminar es predeterminada\r\n    const [direccion] = await pool.query(\r\n      'SELECT usuario_id, predeterminada FROM direcciones WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    if (direccion.length > 0 && direccion[0].predeterminada) {\r\n      // Contar cuántas direcciones tiene el usuario\r\n      const [countResult] = await pool.query(\r\n        'SELECT COUNT(*) as count FROM direcciones WHERE usuario_id = ?',\r\n        [direccion[0].usuario_id]\r\n      );\r\n      \r\n      // Si tiene más de 1 dirección, establecer otra como predeterminada\r\n      if (countResult[0].count > 1) {\r\n        await pool.query(\r\n          `UPDATE direcciones SET predeterminada = TRUE \r\n           WHERE usuario_id = ? AND id != ? \r\n           LIMIT 1`,\r\n          [direccion[0].usuario_id, id]\r\n        );\r\n      }\r\n    }\r\n    \r\n    const [result] = await pool.query(\r\n      'DELETE FROM direcciones WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    return result.affectedRows > 0;\r\n  }\r\n}\r\n\r\nmodule.exports = Direccion;",
      "token.model.js": "const pool = require('../config/database');\r\nconst crypto = require('crypto');\r\n\r\nclass Token {\r\n  static async getById(id) {\r\n    const [rows] = await pool.query(\r\n      'SELECT * FROM tokens WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    return rows.length ? rows[0] : null;\r\n  }\r\n  \r\n  static async getByToken(token) {\r\n    const [rows] = await pool.query(\r\n      'SELECT * FROM tokens WHERE token = ?',\r\n      [token]\r\n    );\r\n    \r\n    return rows.length ? rows[0] : null;\r\n  }\r\n  \r\n  static async getByUsuarioId(usuarioId, tipo) {\r\n    let query = 'SELECT * FROM tokens WHERE usuario_id = ?';\r\n    const params = [usuarioId];\r\n    \r\n    if (tipo) {\r\n      query += ' AND tipo = ?';\r\n      params.push(tipo);\r\n    }\r\n    \r\n    const [rows] = await pool.query(query, params);\r\n    \r\n    return rows;\r\n  }\r\n  \r\n  static async create(tokenData) {\r\n    // Generar token aleatorio si no se proporciona\r\n    const token = tokenData.token || crypto.randomBytes(20).toString('hex');\r\n    \r\n    // Calcular fecha de expiración si no se proporciona\r\n    const ahora = new Date();\r\n    const expiracion = tokenData.fecha_expiracion || new Date(ahora.getTime() + 3600000); // 1 hora por defecto\r\n    \r\n    const [result] = await pool.query(\r\n      `INSERT INTO tokens (\r\n        usuario_id, token, tipo, fecha_expiracion, usado\r\n      ) VALUES (?, ?, ?, ?, ?)`,\r\n      [\r\n        tokenData.usuario_id,\r\n        token,\r\n        tokenData.tipo,\r\n        expiracion,\r\n        tokenData.usado || false\r\n      ]\r\n    );\r\n    \r\n    return { id: result.insertId, token };\r\n  }\r\n  \r\n  static async createRecoveryToken(usuarioId) {\r\n    // Invalidar tokens de recuperación anteriores\r\n    await pool.query(\r\n      `UPDATE tokens SET usado = TRUE \r\n       WHERE usuario_id = ? AND tipo = 'reset_password' AND usado = FALSE`,\r\n      [usuarioId]\r\n    );\r\n    \r\n    // Crear nuevo token\r\n    return this.create({\r\n      usuario_id: usuarioId,\r\n      tipo: 'reset_password',\r\n      fecha_expiracion: new Date(Date.now() + 3600000) // 1 hora\r\n    });\r\n  }\r\n  \r\n  static async validateToken(token, tipo) {\r\n    const [rows] = await pool.query(\r\n      `SELECT * FROM tokens \r\n       WHERE token = ? AND tipo = ? AND usado = FALSE \r\n       AND fecha_expiracion > NOW()`,\r\n      [token, tipo]\r\n    );\r\n    \r\n    return rows.length ? rows[0] : null;\r\n  }\r\n  \r\n  static async markAsUsed(id) {\r\n    const [result] = await pool.query(\r\n      'UPDATE tokens SET usado = TRUE WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    return result.affectedRows > 0;\r\n  }\r\n  \r\n  static async delete(id) {\r\n    const [result] = await pool.query(\r\n      'DELETE FROM tokens WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    return result.affectedRows > 0;\r\n  }\r\n  \r\n  static async deleteExpired() {\r\n    const [result] = await pool.query(\r\n      'DELETE FROM tokens WHERE fecha_expiracion < NOW()'\r\n    );\r\n    \r\n    return result.affectedRows;\r\n  }\r\n}\r\n\r\nmodule.exports = Token;",
      "usuario.model.js": "const pool = require('../config/database');\r\nconst bcrypt = require('bcrypt');\r\n\r\nclass Usuario {\r\n  static async getAll() {\r\n    const [rows] = await pool.query(\r\n      `SELECT id, rut, nombre, apellido, email, telefono, rol, \r\n      activo, ultimo_acceso, fecha_registro, created_at, updated_at\r\n      FROM usuarios`\r\n    );\r\n    \r\n    return rows;\r\n  }\r\n  \r\n  static async getById(id) {\r\n    const [rows] = await pool.query(\r\n      `SELECT id, rut, nombre, apellido, email, telefono, rol, \r\n      activo, ultimo_acceso, fecha_registro, created_at, updated_at\r\n      FROM usuarios\r\n      WHERE id = ?`,\r\n      [id]\r\n    );\r\n    \r\n    if (rows.length === 0) return null;\r\n    \r\n    // Obtener las direcciones del usuario\r\n    const usuario = rows[0];\r\n    usuario.direcciones = await this.getDireccionesByUsuarioId(id);\r\n    \r\n    return usuario;\r\n  }\r\n  \r\n  static async getByEmail(email) {\r\n    const [rows] = await pool.query(\r\n      `SELECT * FROM usuarios WHERE email = ?`,\r\n      [email]\r\n    );\r\n    \r\n    return rows.length ? rows[0] : null;\r\n  }\r\n  \r\n  static async getByRut(rut) {\r\n    const [rows] = await pool.query(\r\n      `SELECT * FROM usuarios WHERE rut = ?`,\r\n      [rut]\r\n    );\r\n    \r\n    return rows.length ? rows[0] : null;\r\n  }\r\n  \r\n  static async getDireccionesByUsuarioId(usuarioId) {\r\n    const [rows] = await pool.query(\r\n      `SELECT * FROM direcciones WHERE usuario_id = ?`,\r\n      [usuarioId]\r\n    );\r\n    \r\n    return rows;\r\n  }\r\n  \r\n  static async create(userData) {\r\n    // Encriptar contraseña\r\n    const hashedPassword = await bcrypt.hash(userData.password, 10);\r\n    \r\n    const [result] = await pool.query(\r\n      `INSERT INTO usuarios (\r\n        rut, nombre, apellido, email, password, telefono, rol\r\n      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,\r\n      [\r\n        userData.rut,\r\n        userData.nombre,\r\n        userData.apellido || 'No especificado',\r\n        userData.email,\r\n        hashedPassword,\r\n        userData.telefono || null,\r\n        userData.rol || 'cliente'\r\n      ]\r\n    );\r\n    \r\n    // Si se proporcionó una dirección, crearla\r\n    if (userData.direccion) {\r\n      await pool.query(\r\n        `INSERT INTO direcciones (\r\n          usuario_id, direccion, comuna, ciudad, region, predeterminada\r\n        ) VALUES (?, ?, ?, ?, ?, TRUE)`,\r\n        [\r\n          result.insertId,\r\n          userData.direccion,\r\n          userData.comuna || 'No especificada',\r\n          userData.ciudad || 'No especificada',\r\n          userData.region || 'No especificada'\r\n        ]\r\n      );\r\n    }\r\n    \r\n    return result.insertId;\r\n  }\r\n  \r\n  static async update(id, userData) {\r\n    let updateQuery = 'UPDATE usuarios SET ';\r\n    const updateValues = [];\r\n    \r\n    // Construir la consulta dinámicamente con los campos proporcionados\r\n    if (userData.nombre) {\r\n      updateQuery += 'nombre = ?, ';\r\n      updateValues.push(userData.nombre);\r\n    }\r\n    \r\n    if (userData.apellido) {\r\n      updateQuery += 'apellido = ?, ';\r\n      updateValues.push(userData.apellido);\r\n    }\r\n    \r\n    if (userData.rut) {\r\n      updateQuery += 'rut = ?, ';\r\n      updateValues.push(userData.rut);\r\n    }\r\n    \r\n    if (userData.telefono !== undefined) {\r\n      updateQuery += 'telefono = ?, ';\r\n      updateValues.push(userData.telefono);\r\n    }\r\n    \r\n    if (userData.rol) {\r\n      updateQuery += 'rol = ?, ';\r\n      updateValues.push(userData.rol);\r\n    }\r\n    \r\n    if (userData.activo !== undefined) {\r\n      updateQuery += 'activo = ?, ';\r\n      updateValues.push(userData.activo);\r\n    }\r\n    \r\n    // Si no hay campos para actualizar\r\n    if (updateValues.length === 0) {\r\n      return false;\r\n    }\r\n    \r\n    // Eliminar la última coma y espacio\r\n    updateQuery = updateQuery.slice(0, -2);\r\n    \r\n    // Agregar condición WHERE\r\n    updateQuery += ' WHERE id = ?';\r\n    updateValues.push(id);\r\n    \r\n    const [result] = await pool.query(updateQuery, updateValues);\r\n    return result.affectedRows > 0;\r\n  }\r\n  \r\n  static async changePassword(id, newPassword) {\r\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n    \r\n    const [result] = await pool.query(\r\n      'UPDATE usuarios SET password = ? WHERE id = ?',\r\n      [hashedPassword, id]\r\n    );\r\n    \r\n    return result.affectedRows > 0;\r\n  }\r\n  \r\n  static async delete(id) {\r\n    // Las direcciones se eliminarán automáticamente por la restricción ON DELETE CASCADE\r\n    const [result] = await pool.query(\r\n      'DELETE FROM usuarios WHERE id = ?',\r\n      [id]\r\n    );\r\n    \r\n    return result.affectedRows > 0;\r\n  }\r\n  \r\n  static async validatePassword(password, hashedPassword) {\r\n    return bcrypt.compare(password, hashedPassword);\r\n  }\r\n  \r\n  static async updateLastAccess(id) {\r\n    await pool.query(\r\n      'UPDATE usuarios SET ultimo_acceso = NOW() WHERE id = ?',\r\n      [id]\r\n    );\r\n  }\r\n}\r\n\r\nmodule.exports = Usuario;"
    },
    "routes": {
      "auth.routes.js": "const express = require('express');\r\nconst router = express.Router();\r\nconst authController = require('../controllers/auth.controller');\r\nconst authMiddleware = require('../middleware/auth.middleware');\r\n\r\nrouter.post('/login', authController.login);\r\nrouter.post('/register', authController.register);\r\nrouter.post('/forgot-password', authController.forgotPassword);\r\nrouter.post('/reset-password', authController.resetPassword);\r\nrouter.get('/validate-token', authMiddleware.verificarToken, authController.validateToken);\r\n\r\nmodule.exports = router;",
      "direcciones.routes.js": "const express = require('express');\r\nconst router = express.Router();\r\nconst direccionesController = require('../controllers/direcciones.controller');\r\nconst authMiddleware = require('../middleware/auth.middleware');\r\n\r\n// Aplicar middleware de autenticación a todas las rutas\r\nrouter.use(authMiddleware.verificarToken);\r\n\r\n// Rutas de direcciones\r\nrouter.get('/usuario/:usuarioId', direccionesController.getDireccionesByUsuario);\r\nrouter.get('/:id', direccionesController.getDireccionById);\r\nrouter.post('/', direccionesController.createDireccion);\r\nrouter.put('/:id', direccionesController.updateDireccion);\r\nrouter.delete('/:id', direccionesController.deleteDireccion);\r\nrouter.patch('/:id/predeterminada', direccionesController.setDireccionPredeterminada);\r\n\r\nmodule.exports = router;",
      "roles.routes.js": "const express = require('express');\r\nconst router = express.Router();\r\nconst rolesController = require('../controllers/roles.controller');\r\nconst authMiddleware = require('../middleware/auth.middleware');\r\nconst rolesMiddleware = require('../middleware/roles.middleware');\r\n\r\n// Todas las rutas requieren autenticación\r\nrouter.use(authMiddleware.verificarToken);\r\n\r\n// Rutas para administradores\r\nrouter.use(rolesMiddleware.esAdmin);\r\n\r\nrouter.get('/', rolesController.getAllRoles);\r\nrouter.get('/:id', rolesController.getRolById);\r\nrouter.post('/', rolesController.createRol);\r\nrouter.put('/:id', rolesController.updateRol);\r\nrouter.delete('/:id', rolesController.deleteRol);\r\n\r\nmodule.exports = router;",
      "usuarios.routes.js": "const express = require('express');\r\nconst router = express.Router();\r\nconst usuariosController = require('../controllers/usuarios.controller');\r\nconst authMiddleware = require('../middleware/auth.middleware');\r\n\r\n// Aplicar middleware de autenticación a todas las rutas\r\nrouter.use(authMiddleware.verificarToken);\r\n\r\n// Rutas de usuarios\r\nrouter.get('/', usuariosController.getAllUsuarios);\r\nrouter.get('/:id', usuariosController.getUsuarioById);\r\nrouter.put('/:id', usuariosController.updateUsuario);\r\nrouter.delete('/:id', usuariosController.deleteUsuario);\r\nrouter.put('/:id/change-password', usuariosController.changePassword);\r\n\r\nmodule.exports = router;"
    }
  }
}